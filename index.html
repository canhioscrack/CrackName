
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>CanhiOS - Qu√©t To√†n B·ªô Token Base64 Trong .dylib</title>
<style>
    body {
      background: #0d0d0d;
      color: #00ffaa;
      font-family: monospace;
      padding: 30px;
      text-align: center;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #1a1a1a;
      border: 2px solid #00ffaa;
      border-radius: 15px;
      padding: 30px;
    }
    input[type="file"], button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      background: #00ffaa;
      color: #000;
      cursor: pointer;
      font-weight: bold;
    }
    #result {
      margin-top: 20px;
      background: #111;
      border-radius: 8px;
      padding: 20px;
      text-align: left;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .token-box {
      margin: 10px 0;
      padding: 10px;
      background: #000;
      border: 1px solid #00ffaa;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .token-box code {
      color: #00ffaa;
      font-size: 14px;
    }
    .copy-btn {
      background: #00ffaa;
      color: #000;
      padding: 5px 10px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: bold;
      cursor: pointer;
      margin-left: 15px;
    }
  </style>
<style>
#buttonNotify {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #00ffaa;
  color: #000;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: bold;
  z-index: 9999;
  display: none;
  box-shadow: 0 0 10px #00ffaa;
}
</style>
<div id="buttonNotify" style="">üîî Thao t√°c</div>
<style>
#copyAlert {
  position: fixed;
  top: 60px;
  right: 20px;
  background: #00ffaa;
  color: #000;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: bold;
  z-index: 9999;
  display: none;
  box-shadow: 0 0 10px #00ffaa;
}
</style>
<div id="copyAlert" style="">üìã Token ƒë√£ ƒë∆∞·ª£c copy!</div>
<style>
body *:not(script):hover {
  transition: box-shadow 0.2s ease-in-out;
  box-shadow: 0 0 8px #00ffaa !important;
}
</style>
<style>
body, h2, h3, label, button, input, #result, code {
  text-shadow: 0 0 6px #00ffaa, 0 0 10px #00ffaa;
}
</style>
</head>
<body>
<script>
    function scanTokens() {
      const file = document.getElementById("dylibFile").files[0];
      if (!file) return alert("Vui l√≤ng ch·ªçn file .dylib");

      const reader = new FileReader();
      reader.onload = function(e) {
        const bytes = new Uint8Array(e.target.result);
        let text = '';
        for (let i = 0; i < bytes.length; i++) {
          const byte = bytes[i];
          if (byte >= 32 && byte <= 126) {
            text += String.fromCharCode(byte);
          } else {
            text += ' ';
          }
        }

        const base64Regex = /[A-Za-z0-9+/=]{60,}/g;
        const matches = [...new Set(text.match(base64Regex))]; // Remove duplicates

        const result = document.getElementById("result");
        if (!matches || matches.length === 0) {
          result.innerHTML = "‚ùå Kh√¥ng t√¨m th·∫•y token base64 n√†o!";
          return;
        }

        result.innerHTML = `‚úÖ T√¨m th·∫•y ${matches.length} token base64:<br><br>`;
        matches.forEach((token, idx) => {
          result.innerHTML += `
            <div class="token-box">
              <code>${token}</code>
              <button class="copy-btn" onclick="copyToken('${token}')">üìã Copy</button>
            </div>
          `;
        });
      };
      reader.readAsArrayBuffer(file);
    }
  
function replaceToken() {
  const oldToken = document.getElementById("oldToken").value.trim();
  const newToken = document.getElementById("newToken").value.trim();
  const fileInput = document.getElementById("dylibFile");
  if (!fileInput.files[0]) return alert("Ch∆∞a c√≥ file ƒë·ªÉ x·ª≠ l√Ω.");
  if (!oldToken || !newToken) return alert("Vui l√≤ng nh·∫≠p c·∫£ token g·ªëc v√† m·ªõi.");
  if (oldToken.length !== newToken.length) return alert("Token m·ªõi ph·∫£i c√πng ƒë·ªô d√†i v·ªõi token g·ªëc!");

  const reader = new FileReader();
  reader.onload = function(e) {
    const bytes = new Uint8Array(e.target.result);
    const encoder = new TextEncoder();
    const oldBytes = encoder.encode(oldToken);
    const newBytes = encoder.encode(newToken);

    let offset = -1;
    for (let i = 0; i <= bytes.length - oldBytes.length; i++) {
      let found = true;
      for (let j = 0; j < oldBytes.length; j++) {
        if (bytes[i + j] !== oldBytes[j]) {
          found = false;
          break;
        }
      }
      if (found) {
        offset = i;
        break;
      }
    }

    if (offset === -1) return alert("‚ùå Kh√¥ng t√¨m th·∫•y token g·ªëc trong file!");

    for (let j = 0; j < newBytes.length; j++) {
      bytes[offset + j] = newBytes[j];
    }

    const blob = new Blob([bytes], {type: "application/octet-stream"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "patched_token.dylib";
    a.click();
  };
  reader.readAsArrayBuffer(fileInput.files[0]);
}


function showNotify(msg) {
  const n = document.getElementById("buttonNotify");
  n.innerText = "üîî " + msg;
  n.style.display = "block";
  setTimeout(() => { n.style.display = "none"; }, 2500);
}


function showCopyAlert() {
  const a = document.getElementById("copyAlert");
  a.style.display = "block";
  setTimeout(() => { a.style.display = "none"; }, 2000);
}


function copyToken(token) {
  navigator.clipboard.writeText(token);
  showCopyAlert();
}

</script>
<!-- Particles.js -->
<div id="particles-js" style="z-index:0;"></div>
<style>
#particles-js {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
}
</style>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script>
particlesJS("particles-js", {
  "particles": {
    "number": { "value": 220, "density": { "enable": true, "value_area": 800 } },
    "color": { "value": "#00ffaa" },
    "shape": {
      "type": "circle",
      "stroke": { "width": 0, "color": "#000" },
      "polygon": { "nb_sides": 6 }
    },
    "opacity": {
      "value": 0.5, "random": false,
      "anim": { "enable": false }
    },
    "size": {
      "value": 3,
      "random": true,
      "anim": { "enable": false }
    },
    "line_linked": {
      "enable": true,
      "distance": 110,
      "color": "#00ffaa",
      "opacity": 0.45,
      "width": 1.2
    },
    "move": {
      "enable": true,
      "speed": 1.5,
      "direction": "none",
      "random": false,
      "straight": false,
      "out_mode": "bounce",
      "bounce": true
    }
  },
  "interactivity": {
    "detect_on": "canvas",
    "events": {
      "onhover": { "enable": true, "mode": "repulse" },
      "onclick": { "enable": true, "mode": "push" },
      "resize": true
    },
    "modes": {
      "repulse": { "distance": 120, "duration": 0.4 },
      "push": { "particles_nb": 6 }
    }
  },
  "retina_detect": true
});
</script>
<script src="https://unpkg.com/snowstorm@latest/snowstorm-min.js"></script>
<script>
snowStorm.flakesMax = 100;
snowStorm.flakesMaxActive = 90;
snowStorm.animationInterval = 25;
snowStorm.useTwinkleEffect = true;
snowStorm.snowCharacter = "‚ùÑ";
snowStorm.flakeColor = "#ffffff";
</script>
<div id="particles-js" style="position: fixed; top: 0; left: 0; width: auto; height: 100%;
z-index: -1; pointer-events: none;"></div>
<script>
particlesJS("particles-menu", {
  "particles": {
    "number": { "value": 80, "density": { "enable": true, "value_area": 800 } },
    "color": { "value": "#00ffaa" },
    "shape": {
      "type": "circle",
      "stroke": { "width": 0, "color": "#000" },
      "polygon": { "nb_sides": 5 }
    },
    "opacity": {
      "value": 0.4, "random": false,
      "anim": { "enable": false }
    },
    "size": {
      "value": 2.5,
      "random": true,
      "anim": { "enable": false }
    },
    "line_linked": {
      "enable": true,
      "distance": 100,
      "color": "#00ffaa",
      "opacity": 0.35,
      "width": 1
    },
    "move": {
      "enable": true,
      "speed": 1.2,
      "direction": "none",
      "random": false,
      "straight": false,
      "out_mode": "bounce",
      "bounce": true
    }
  },
  "interactivity": {
    "detect_on": "canvas",
    "events": {
      "onhover": { "enable": true, "mode": "repulse" },
      "onclick": { "enable": true, "mode": "push" },
      "resize": true
    },
    "modes": {
      "repulse": { "distance": 120, "duration": 0.4 },
      "push": { "particles_nb": 4 }
    }
  },
  "retina_detect": true
});
</script>
<script>
function readBinary(file, callback) {
  const reader = new FileReader();
  reader.onload = () => callback(new Uint8Array(reader.result));
  reader.readAsArrayBuffer(file);
}

function checkMenu() {
  const file = document.getElementById("menuFile").files[0];
  if (!file) return alert("Ch·ªçn file .dylib tr∆∞·ªõc ƒë√£!");
  readBinary(file, (bytes) => {
    const text = new TextDecoder().decode(bytes);
    const match = text.match(/Menu[^\0\n]{3,30}/);
    document.getElementById("menuNameResult").innerText =
      match ? "üîç T√™n menu t√¨m ƒë∆∞·ª£c: " + match[0] : "‚ùå Kh√¥ng t√¨m th·∫•y t√™n menu!";
  });
}

function replaceMenuName() {
  const file = document.getElementById("menuFile").files[0];
  const newName = document.getElementById("newMenuName").value;
  if (!file || !newName) return alert("Ch·ªçn file v√† nh·∫≠p t√™n menu m·ªõi!");

  readBinary(file, (bytes) => {
    const oldText = new TextDecoder().decode(bytes);
    const match = oldText.match(/Menu[^\0\n]{3,30}/);
    if (!match) return alert("Kh√¥ng t√¨m th·∫•y t√™n menu ƒë·ªÉ thay!");

    const oldName = match[0];
    const oldBytes = new TextEncoder().encode(oldName);
    const newBytes = new TextEncoder().encode(newName.padEnd(oldName.length, "\0"));
    const patched = new Uint8Array(bytes);

    for (let i = 0; i < bytes.length - oldBytes.length; i++) {
      let found = true;
      for (let j = 0; j < oldBytes.length; j++) {
        if (bytes[i + j] !== oldBytes[j]) { found = false; break; }
      }
      if (found) {
        for (let j = 0; j < newBytes.length; j++) patched[i + j] = newBytes[j];
        break;
      }
    }

    const blob = new Blob([patched], { type: "application/octet-stream" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "Patched_Menu_" + file.name;
    a.click();
  });
}
</script>
<div style="max-width: 800px; margin: 60px auto; background: rgba(0,0,0,0.6); border: 2px solid #00ffaa; border-radius: 20px; padding: 30px;">
<h2 style="color: #00ffaa; text-align: center;">üìù Ki·ªÉm Tra &amp; Thay T√™n Menu</h2>
<label style="color:#00ffaa; font-weight:bold; z-index:2; position:relative;">üìÇ Ch·ªçn File .dylib:</label><br/>
<input accept=".dylib" id="menuFileInput" style="width: auto; margin-bottom: 15px; z-index:2; position:relative;" type="file"/><br/>
<label style="color:#00ffaa; font-weight:bold; z-index:2; position:relative;">üîç Nh·∫≠p T√™n Menu G·ªëc:</label><br/>
<input id="menuOld" placeholder="VD: Menu by..." style="width: auto; margin-bottom: 15px; z-index:2; position:relative;" type="text"/><br/>
<label style="color:#00ffaa; font-weight:bold; z-index:2; position:relative;">üîÅ Nh·∫≠p T√™n Menu M·ªõi:</label><br/>
<input id="menuNew" placeholder="T√™n thay th·∫ø mu·ªën ƒë·ªïi th√†nh" style="width: auto; margin-bottom: 20px; z-index:2; position:relative;" type="text"/><br/>
<button onclick="checkMenuName()" style="padding: 10px 20px; font-weight:bold; z-index:2; position:relative;">üîé Check Menu</button>
<button onclick="replaceMenuNameNew()" style="padding: 10px 20px; font-weight:bold; margin-left: 20px; z-index:2; position:relative;">üíæ Thay &amp; T·∫£i File M·ªõi</button>
<div id="menuResultArea" style="color: #00ffaa; margin-top: 20px; font-size: 16px;"></div>
</div>
<script>
function checkMenuName() {
  const file = document.getElementById("menuFileInput").files[0];
  const oldName = document.getElementById("menuOld").value;
  if (!file || !oldName) return alert("Ch·ªçn file v√† nh·∫≠p t√™n menu g·ªëc ƒë·ªÉ ki·ªÉm tra!");

  readBinary(file, (bytes) => {
    const text = new TextDecoder().decode(bytes);
    const found = text.includes(oldName);
    document.getElementById("menuResultArea").innerText = found
      ? "‚úÖ T√¨m th·∫•y t√™n menu trong file!"
      : "‚ùå Kh√¥ng t√¨m th·∫•y t√™n menu!";
  });
}

function replaceMenuNameNew() {
  const file = document.getElementById("menuFileInput").files[0];
  const oldName = document.getElementById("menuOld").value;
  const newName = document.getElementById("menuNew").value;
  if (!file || !oldName || !newName) return alert("Vui l√≤ng nh·∫≠p ƒë·ªß th√¥ng tin!");

  readBinary(file, (bytes) => {
    const oldBytes = new TextEncoder().encode(oldName);
    const newBytes = new TextEncoder().encode(newName.padEnd(oldBytes.length, "\0"));
    const patched = new Uint8Array(bytes);
    let replaced = false;

    for (let i = 0; i < bytes.length - oldBytes.length; i++) {
      let match = true;
      for (let j = 0; j < oldBytes.length; j++) {
        if (bytes[i + j] !== oldBytes[j]) {
          match = false;
          break;
        }
      }
      if (match) {
        for (let j = 0; j < oldBytes.length; j++) {
          patched[i + j] = newBytes[j];
        }
        replaced = true;
        break;
      }
    }

    if (!replaced) return alert("‚ùå Kh√¥ng t√¨m th·∫•y t√™n menu ƒë·ªÉ thay!");

    const blob = new Blob([patched], { type: "application/octet-stream" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "Patched_Menu_" + file.name;
    a.click();
  });
}
</script>
</body>
</html>
